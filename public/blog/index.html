<!doctype html><html lang=ko class=scroll-smooth><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Blog | Dev Note by sw'Lee</title><meta name=description content="개발 메모와 기록"><link rel=canonical href=https://swlee3306.github.io/sulee_portfolio/blog/><meta name=theme-color content="#111111"><link rel=icon href=../favicon.svg type=image/svg+xml><link rel=apple-touch-icon href=../favicon.svg><meta name=author content="이상욱"><link rel=dns-prefetch href=//img.shields.io><link rel=preconnect href=https://img.shields.io crossorigin><meta property="og:type" content="article"><meta property="og:url" content="https://swlee3306.github.io/sulee_portfolio/blog/"><meta property="og:title" content="Blog | Dev Note by sw'Lee"><meta property="og:description" content="개발 메모와 기록"><meta property="og:image" content="https://swlee3306.github.io/images/og-default.svg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Blog | Dev Note by sw'Lee"><meta name=twitter:description content="개발 메모와 기록"><meta name=twitter:image content="https://swlee3306.github.io/images/og-default.svg"><link rel=preload as=style href="../css/styles.css?v=1758859227"><link rel=stylesheet href="../css/styles.css?v=1758859227"><link rel=alternate type=application/rss+xml title=RSS href=../blog/index.xml><script type=application/ld+json>{"@context":"https://schema.org","@type":"Person","name":"이상욱","url":"https:\/\/swlee3306.github.io\/sulee_portfolio\/","sameAs":[]}</script></head><body class="min-h-screen bg-background font-sans antialiased"><a href=#main-content class=skip-link style=position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden>본문으로 건너뛰기</a><header class=site-header><div class="container nav"><a class=brand href=../><span class="font-bold text-xl">Dev Note by sw'Lee</span></a><nav class=flex><ul><li><a href=../ class=nav-link>Home</a></li><li><a href=../projects/ class=nav-link>Projects</a></li><li><a href=../blog/ class=nav-link>Blog</a></li><li><a href=../tags/ class=nav-link>Tags</a></li><li><a href=../about/ class=nav-link>About</a></li><li><a href=../contact/ class=nav-link>Contact</a></li></ul></nav><button class="md:hidden p-2 rounded-md hover:bg-accent" aria-label="메뉴 열기" aria-expanded=false>
<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg></button></div></header><script src=../js/mobile-menu.js defer></script><main id=main-content role=main class=container><section class=section><h1>Blog</h1><div class=content><p>개발 과정에서의 실험, 문제 해결 과정, 그리고 유용한 메모들을 기록합니다.</p></div><div class=cards><article class=card><a href=../blog/make-snmprec-case-study/><img class=thumb src=https://swlee3306.github.io/sulee_portfolio/gen/thumbs/f9499f4f42e576631db5a92fe1dc3290.svg alt="make-snmprec 케이스 스터디 cover" loading=lazy decoding=async width=640 height=360 sizes="(max-width: 700px) 100vw, 640px"></a><h2><a href=../blog/make-snmprec-case-study/>make-snmprec 케이스 스터디</a></h2><p class=meta>2025-09-19</p><p class=summary-text>운영 환경에 가까운 SNMP 시뮬레이션 데이터를 재현하는 도구를 설계/구현하며, 데이터 모델·엣지 케이스·검증·CLI UX를 통해 신뢰성과 생산성을 동시에 높였습니다.</p><p><a class=btn href=../blog/make-snmprec-case-study/ aria-label="프로젝트 make-snmprec 케이스 스터디 자세히 보기">자세히 보기</a></p></article><article class=card><a href=../blog/introducing-blog/><img class=thumb src=https://swlee3306.github.io/sulee_portfolio/gen/thumbs/08fc1866cad2d67a952bd612dba8dd3d.svg alt="블로그를 시작합니다 cover" loading=lazy decoding=async width=640 height=360 sizes="(max-width: 700px) 100vw, 640px"></a><h2><a href=../blog/introducing-blog/>블로그를 시작합니다</a></h2><p class=meta>2025-09-19</p><p class=summary-text>포트폴리오 사이트에 가벼운 개발 기록을 남기기 위한 블로그 섹션을 추가했습니다.</p><p><a class=btn href=../blog/introducing-blog/ aria-label="프로젝트 블로그를 시작합니다 자세히 보기">자세히 보기</a></p></article><article class=card><a href=../blog/snmp-backend-engineers-guide/><img class=thumb src=https://swlee3306.github.io/sulee_portfolio/gen/thumbs/147744cce3d10ba0802427ae575d5558.svg alt="백엔드 엔지니어를 위한 SNMP cover" loading=lazy decoding=async width=640 height=360 sizes="(max-width: 700px) 100vw, 640px"></a><h2><a href=../blog/snmp-backend-engineers-guide/>백엔드 엔지니어를 위한 SNMP</a></h2><p class=meta>2025-01-15</p><p class=summary-text>백엔드 엔지니어를 위한 SNMP 실전 가이드: MIB, OID, traps vs polling의 핵심 개념과 Go를 활용한 실용적인 네트워크 모니터링 구현 방법을 소개합니다.</p><p><a class=btn href=../blog/snmp-backend-engineers-guide/ aria-label="프로젝트 백엔드 엔지니어를 위한 SNMP 자세히 보기">자세히 보기</a></p></article><article class=card><a href=../blog/go-benchmarking-profiling-workflow/><img class=thumb src=https://swlee3306.github.io/sulee_portfolio/gen/thumbs/72ea9dd7575694654d55bc80e456a0f9.svg alt="Go 벤치마킹과 프로파일링 워크플로우 cover" loading=lazy decoding=async width=640 height=360 sizes="(max-width: 700px) 100vw, 640px"></a><h2><a href=../blog/go-benchmarking-profiling-workflow/>Go 벤치마킹과 프로파일링 워크플로우</a></h2><p class=meta>2025-01-15</p><p class=summary-text>Go 성능 최적화를 위한 실전 벤치마킹과 프로파일링 워크플로우: testing, bench, pprof, flamegraphs를 활용한 성능 문제 해결과 최적화 방법을 단계별로 소개합니다.</p><p><a class=btn href=../blog/go-benchmarking-profiling-workflow/ aria-label="프로젝트 Go 벤치마킹과 프로파일링 워크플로우 자세히 보기">자세히 보기</a></p></article><article class=card><a href=../blog/hugo-subpath-safe-links-relref-guide/><img class=thumb src=https://swlee3306.github.io/sulee_portfolio/gen/thumbs/5aa7d9ab9d1befe5ed0f8866cacaa8be.svg alt="Hugo GitHub Pages 서브패스 링크 cover" loading=lazy decoding=async width=640 height=360 sizes="(max-width: 700px) 100vw, 640px"></a><h2><a href=../blog/hugo-subpath-safe-links-relref-guide/>Hugo GitHub Pages 서브패스 링크</a></h2><p class=meta>2025-01-15</p><p class=summary-text>GitHub Pages 서브패스 환경에서 Hugo의 relref와 relURL을 활용한 안전한 내부 링크 구현법과 자주 발생하는 문제점들을 실전 예제로 해결하는 가이드</p><p><a class=btn href=../blog/hugo-subpath-safe-links-relref-guide/ aria-label="프로젝트 Hugo GitHub Pages 서브패스 링크 자세히 보기">자세히 보기</a></p></article><article class=card><a href=../blog/system-info-collector-case-study/><img class=thumb src=https://swlee3306.github.io/sulee_portfolio/gen/thumbs/af2cda9a3a61d48130774ddbb96fa03a.svg alt="system-Info-collector 케이스 스터디 cover" loading=lazy decoding=async width=640 height=360 sizes="(max-width: 700px) 100vw, 640px"></a><h2><a href=../blog/system-info-collector-case-study/>system-Info-collector 케이스 스터디</a></h2><p class=meta>2025-01-15</p><p class=summary-text>CPU/MEM/Disk 수집부터 신뢰성 확보까지: 샘플링, 백오프/재시도, CSV+DB 이중 로깅, 로테이션을 통한 호스트 관측성 구축 실전 가이드</p><p><a class=btn href=../blog/system-info-collector-case-study/ aria-label="프로젝트 system-Info-collector 케이스 스터디 자세히 보기">자세히 보기</a></p></article><article class=card><a href=../blog/go-networking-tips-timeouts-backoff-idempotency/><img class=thumb src=https://swlee3306.github.io/sulee_portfolio/gen/thumbs/7e8e7103974d9b99c07f698d4a24c5ef.svg alt="Go 네트워킹 팁: 타임아웃, 백오프, 멱등성 cover" loading=lazy decoding=async width=640 height=360 sizes="(max-width: 700px) 100vw, 640px"></a><h2><a href=../blog/go-networking-tips-timeouts-backoff-idempotency/>Go 네트워킹 팁: 타임아웃, 백오프, 멱등성</a></h2><p class=meta>2025-01-15</p><p class=summary-text><h2 id=tldr>TL;DR</h2><p>Go에서 안정적인 네트워크 애플리케이션을 구축하려면 적절한 타임아웃 처리, 지능적인 재시도 전략, 멱등성 연산이 필요합니다. 이 가이드는 컨텍스트/데드라인, 지수 백오프, 서킷 브레이커에 대한 필수 패턴을 실제 예제와 함께 다룹니다.</p><h2 id=배경>배경</h2><p>Go에서 네트워크 프로그래밍은 고유한 도전 과제를 제시합니다: 연결이 실패할 수 있고, 서비스가 일시적으로 사용 불가능할 수 있으며, 네트워크 분할이 연쇄 실패를 일으킬 수 있습니다. 적절한 안정성 패턴 없이는 애플리케이션이 취약하고 예측 불가능해집니다.</p><h2 id=문제점>문제점</h2><p>Go 애플리케이션에서 흔한 네트워킹 문제들:</p><ul><li><strong>타임아웃 없음</strong>은 연결이 멈추고 리소스 누수를 야기합니다</li><li><strong>단순한 재시도</strong>는 실패하는 서비스를 압도할 수 있습니다</li><li><strong>비멱등성 연산</strong>은 재시도 시 데이터 손상을 일으킵니다</li><li><strong>서킷 브레이커 없음</strong>은 연쇄 실패를 허용합니다</li><li><strong>부적절한 에러 처리</strong>는 디버깅을 거의 불가능하게 만듭니다</li></ul><h2 id=타임아웃-전략>타임아웃 전략</h2><h3 id=데드라인과-함께하는-컨텍스트>데드라인과 함께하는 컨텍스트</h3><p>Go 네트워킹에서 가장 중요한 패턴은 타임아웃과 함께 <code>context.Context</code>를 사용하는 것입니다:</p></p><p><a class=btn href=../blog/go-networking-tips-timeouts-backoff-idempotency/ aria-label="프로젝트 Go 네트워킹 팁: 타임아웃, 백오프, 멱등성 자세히 보기">자세히 보기</a></p></article><article class=card><a href=../blog/github-actions-hugo-pipeline/><img class=thumb src=https://swlee3306.github.io/sulee_portfolio/gen/thumbs/c2d845b78274d6b2911e9f8c855f4a99.svg alt="Hugo GitHub Actions 파이프라인 cover" loading=lazy decoding=async width=640 height=360 sizes="(max-width: 700px) 100vw, 640px"></a><h2><a href=../blog/github-actions-hugo-pipeline/>Hugo GitHub Actions 파이프라인</a></h2><p class=meta>2025-01-15</p><p class=summary-text>워크플로우 기본, 캐시, 빌드 플래그, 아티팩트 팁을 활용한 Hugo 사이트의 제로 다운타임 배포 파이프라인</p><p><a class=btn href=../blog/github-actions-hugo-pipeline/ aria-label="프로젝트 Hugo GitHub Actions 파이프라인 자세히 보기">자세히 보기</a></p></article><article class=card><a href=../blog/dynamic-svg-thumbnails-hugo/><img class=thumb src=https://swlee3306.github.io/sulee_portfolio/gen/thumbs/ac3ae4622e0327b6f069024782c306ec.svg alt="Hugo 동적 SVG 썸네일 cover" loading=lazy decoding=async width=640 height=360 sizes="(max-width: 700px) 100vw, 640px"></a><h2><a href=../blog/dynamic-svg-thumbnails-hugo/>Hugo 동적 SVG 썸네일</a></h2><p class=meta>2025-01-15</p><p class=summary-text>ExecuteAsTemplate, 브랜드 토큰, 폴백 시스템을 활용한 Hugo 리소스 시스템으로 외부 에셋 없이 시각적 일관성 확보</p><p><a class=btn href=../blog/dynamic-svg-thumbnails-hugo/ aria-label="프로젝트 Hugo 동적 SVG 썸네일 자세히 보기">자세히 보기</a></p></article><article class=card><a href=../blog/logging-strategy-dev-to-prod/><img class=thumb src=https://swlee3306.github.io/sulee_portfolio/gen/thumbs/6f427775c717f6c67d268ba0f24ad1e7.svg alt="개발부터 프로덕션까지 로깅 전략 cover" loading=lazy decoding=async width=640 height=360 sizes="(max-width: 700px) 100vw, 640px"></a><h2><a href=../blog/logging-strategy-dev-to-prod/>개발부터 프로덕션까지 로깅 전략</a></h2><p class=meta>2025-01-15</p><p class=summary-text><h2 id=tldr>TL;DR</h2><ul><li><strong>목표</strong>: 개발부터 프로덕션까지 확장 가능한 로깅 시스템 구축</li><li><strong>핵심</strong>: 구조화된 로깅, 로테이션 정책, 중앙화된 수집, 성능 최적화</li><li><strong>결과</strong>: 디버깅 효율성 향상, 운영 가시성 확보, 시스템 안정성 증대</li></ul><h2 id=context>Context</h2><p>현대의 분산 시스템에서 로깅은 단순한 디버깅 출력을 넘어서 관찰 가능성의 핵심 구성 요소입니다. 애플리케이션이 개발부터 프로덕션까지 확장되면서, 로깅 전략도 증가하는 볼륨, 복잡성, 운영 요구사항을 처리할 수 있도록 진화해야 합니다.</p><h2 id=problem>Problem</h2><p>대부분의 애플리케이션은 간단한 <code>fmt.Println</code>이나 기본 로깅으로 시작하지만, 이 접근법은 프로덕션에서 문제가 됩니다:</p></p><p><a class=btn href=../blog/logging-strategy-dev-to-prod/ aria-label="프로젝트 개발부터 프로덕션까지 로깅 전략 자세히 보기">자세히 보기</a></p></article></div><nav class=pagination><ul class="pagination pagination-default"><li class="page-item disabled"><a aria-disabled=true aria-label=First class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;&#171;</span></a></li><li class="page-item disabled"><a aria-disabled=true aria-label=Previous class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;</span></a></li><li class="page-item active"><a aria-current=page aria-label="Page 1" class=page-link role=button>1</a></li><li class=page-item><a href=../blog/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class=page-item><a href=../blog/page/2/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=../blog/page/2/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></nav></section></main><footer class=site-footer><div class=container><div class="flex flex-col md:flex-row justify-between items-center gap-4 py-8"><p class="text-sm text-muted-foreground">© 2025 이상욱</p><div class="flex items-center gap-4"></div></div></div></footer></body></html>